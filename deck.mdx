import { CodeSurfer } from 'mdx-deck-code-surfer';

# Functional Programming
---
# What?
- Paradigm based on first-class functions
- Supports functional _purity_
- Outcomes are deterministic
- Functions can be composed
- Follow a _declarative_ style, rather than _imperative_ (what, not how)
---
# Why
- Easier to test
- Easier to reason about outcomes
- Less complexity
- Ideally, less code
- Ultimately, fewer bugs
---
# Pure Functions
What are some characteristics?
---
# Pure Functions
- Deterministic - they produce the same output for a given input
- Produce no side-effects
- Independent of context
---
<CodeSurfer
  title='Deterministic'
  code={require('!raw-loader!./snippets/deterministic.js')}
  language='javascript'
  steps={[
    { notes: 'Functions are deterministic if, given an input, their output is always the same' },
    { lines: [3], notes: 'f will always return 3 if its input is 2' }
  ]}
/>
---
<CodeSurfer
  title='No Side Effects!'
  code={require('!raw-loader!./snippets/no-side-effects.js')}
  language='javascript'
  steps={[
    { lines: [1], notes: 'Pure functions effect nothing external' },
    { lines: [1, 3], notes: 'This function is pure' },
    { range: [5, 9], notes: 'What about this one? Why?' },
    { lines: [11, 12], notes: 'This function is impure' },
    { lines: [14, 15], notes: 'When we call it, value of y can change' }
  ]}
/>
---
<CodeSurfer
  title='No Context!'
  code={require('!raw-loader!./snippets/no-context.js')}
  language='javascript'
  steps={[
    { lines: [1], notes: 'Pure functions are context-free' },
    { lines: [1, 3], notes: 'This function is pure' },
    { lines: [6], notes: 'What about this one? Why?' },
    { lines: [5, 6], notes: 'This function is not, it relies on the value of y' },
    { lines: [10, 12], notes: 'If y changes, the result of the function changes' }
  ]}
/>
---
# Referential Transparency
- Pure functions can be said to be referentially transparent
- Since their value is the same for a given input, they can be substituted for their return value
- Allows for easier memoization, compiler optimization, etc.
---
# Referential Transparency
Why is purity important for this?
---
<CodeSurfer
  title='Referential Transparency'
  code={require('!raw-loader!./snippets/referential-transparency.js')}
  language='javascript'
/>
---
<CodeSurfer
  title='Referential Transparency'
  code={require('!raw-loader!./snippets/referential-transparency-replace.js')}
  language='javascript'
/>
---
<CodeSurfer
  title='Referential Transparency'
  code={require('!raw-loader!./snippets/referential-transparency-replace-bad.js')}
  language='javascript'
  steps={[
    { notes: 'Can g still be re-written?' },
  ]}
/>
---
# First-Class Functions
Why do we mean by this?
---
# First-Class Functions
- They can be stored in a variable, object, or array
- They can be passed as an argument
- They can be returned from another function
---
<CodeSurfer
  title='First Class Functions'
  code={require('!raw-loader!./snippets/first-class-functions.js')}
  language='javascript'
  steps={[
    { notes: 'JS lets of treat functions as first-class citizens' },
    { lines: [1, 2], notes: 'We can set up some basic functions' },
    { lines: [3, 4], notes: 'We can assign those as values to more meaningful aliases' },
    { range: [6, 10], notes: 'We can assemble an object to bundle ideas' },
    { range: [12, 13], notes: 'Or accept a function as input' },
    { range: [15, 23], notes: 'and then build combined effects.' }
  ]}
/>
---
# Higher-Order Functions
What are they?
---
# Higher-Order Functions
- Take a function as input, or
- Return a function as output, or
- Both!
---
<CodeSurfer
  title='Higher-Order Functions'
  code={require('!raw-loader!./snippets/higher-order-functions.js')}
  language='javascript'
  steps={[
    { notes: 'JS has some built-in methods which are higher-order functions' },
    { lines: [2], notes: 'isEven is a pure function' },
    { lines: [4], notes: 'filter is a higher-order function, isEven is passed as a function (without evaluation)' }
  ]}
/>
---
# Arity
the number of arguments a function has

- Unary/1-ary: a function with *one* argument
- 2-ary: a function with *two* arguments
- N-ary: a function with _n_ arguments
---
What other specific arity are we familiar with?
---
## Ternary operator `? :`
Three arguments: a condition and two functions
`(condition, f, g) => if (condition) { f } else { g }`
---
# Partial Application
---
# Partial Application
- Providing some, but not all, arguments
- Produce a new function with some values "built in"
- Allows us to "bind" some arguments and evaluate returned functions later
- Resulting function has lower arity (ie, fewer arguments)
---
<CodeSurfer
  title='Partial Application'
  code={require('!raw-loader!./snippets/partial-application.js')}
  language='javascript'
  steps={[
    { lines: [1], notes: 'A typical binary function' },
    { lines: [2], notes: 'which we can call with both arguments' },
    { lines: [4, 5], notes: 'Args can be partially applied to get new 1-ary functions' },
    { lines: [7, 8], notes: 'which can later be used' },
  ]}
/>
---
# Currying

- Convert N-ary functions into _N_ unary functions
- Allows for convenient partial application
<!-- - Allows using a _point-free_ style to reduce cognitive load -->
---
<CodeSurfer
  title='Currying'
  code={require('!raw-loader!./snippets/curry.js')}
  language='javascript'
  steps={[
    { lines: [1, 2], notes: 'The same 2-ary function' },
    { lines: [4], notes: 'Can be curried to a function which returns a function' },
    { lines: [6, 7], notes: 'The second function can be stored as a variable' },
    { lines: [9, 10], notes: 'and be evaluated later' },
    { lines: [6, 7], notes: 'Curried functions allow for "point-free" style' },
  ]}
/>
---
# Point-free
---
# Point-free
Omit unecessary arguments

- Smaller, cleaner code to read
- Less cognitive load
- More declarative (imposing args is imperative)
---
<CodeSurfer
  title='Point-free'
  code={require('!raw-loader!./snippets/point-free.js')}
  language='javascript'
  steps={[
    { lines: [1, 2], notes: 'The same 2-ary function... again' },
    { lines: [3, 4], notes: 'These two partial applications are equivalent' },
    { lines: [3, 4], notes: 'the curried version allows us to omit the argument' },
  ]}
/>
---
# Composition
Combining the effect of multiple functions together

- Helps us build up complexity from a number of small, simple steps
- Only First-Class Functions can be composed (why?)
- Typically expressed as `fâˆ˜g(x) = f(g(x))` ("f of g of x")
---
<CodeSurfer
  title='Composition'
  code={require('!raw-loader!./snippets/compose.js')}
  language='javascript'
  steps={[
    { lines: [1, 2, 3], notes: 'We start with simple functions' },
    { lines: [5], notes: 'We can combine them manually, of course' },
    { lines: [7], notes: 'But we can instead define a helper to compose two functions' },
    { lines: [9, 10], notes: 'Because we expect to do this often' },
    { lines: [12, 13], notes: 'to simplify complex calculations' },
  ]}
/>
---
What about more than two functions composed together?
---
<CodeSurfer
  title='Pipe is everything'
  code={require('!raw-loader!./snippets/pipe.js')}
  language='javascript'
  steps={[
    { lines: [2], notes: 'Pipe takes one or more functions as arguments' },
    { lines: [3], notes: 'We reduce over the functions' },
    { lines: [4], notes: 'Calling each, in turn, with the result of the last' },
    { lines: [8, 9, 10, 12, 13, 14, 15, 16], notes: 'And now we can compose our trivially simple units into more complex systems' }
  ]}
/>
---
# Immutability
- If you've noticed, in all of our examples so far, there have been no uses of `let`, or `var`
- In FP, nothing is variable; while `x` is in scope, it can never change
- FP favours immutability; the result of one function is passed to the input of another, onward until we end at our result
- State changes prevent referential transparency
- Reducers are pure functions
---
# Testing
- Pure, atomic functions are easily testable
- If we test small functions, we don't need to test complex composition
- We can infer the outcome will be as expected
---
<CodeSurfer
  title='Testing'
  code={require('!raw-loader!./snippets/testing.js')}
  language='javascript'
  steps={[
    { lines: [4, 15], notes: 'These tests are trivial'},
    { lines: [24, 25, 26, 27], notes: 'We don\'t need to test the composition, all of our steps are covered!' }
  ]}
/>
---
# Thoughts
- These techniques can be used to reduce complex systems into a series of incredibly simple, testable steps
- Not replacement for OOP or imperative techniques, can all be used in unison
- This is just the beginning, FP is a deep and wide field of study
- javascript is well-suited for FP
---
# Caution
- As with all tools, FP can be mis-used
- It is entirely possible to create an over-curried mess
- Always keep an eye on the goal of readability and maintainability
- Since javascript allows multiple paradigms, _use when appropriate_
---
# Codebase Example: Selectors
Simplifying our codebase for ease of reasoning and maintenance
---
# Exercises 
- Write `reduce`
- Write `filter` and `map` using your `reduce`
